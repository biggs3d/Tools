import re
from pathlib import Path
from typing import Dict, List, Set, Tuple

NUMBER_OF_HEADER_LINES_TO_SEARCH = 21
PATH_TO_SEARCH = "../../../../libs"
OUTPUT_PATH = "./gathered_imports.js"


class TypeScriptImportAnalyzer:
    def __init__(self, root_path: str = PATH_TO_SEARCH):
        self.root_path = Path(root_path)
        self.export_map: Dict[str, str] = {}

    def find_index_files(self) -> List[Path]:
        """Find all barrelsby-generated index.ts files in the project structure."""
        index_files = []
        for path in self.root_path.rglob("index.ts"):
            path_str = str(path)
            if "node_modules" not in path_str and "dist" not in path_str:
                # Verify it's a barrelsby file by checking first few lines
                with open(path, 'r', encoding='utf-8') as f:
                    first_lines = [f.readline().strip() for _ in
                                   range(NUMBER_OF_HEADER_LINES_TO_SEARCH)]  # Limit search
                    if any("@file Automatically generated by barrelsby" in line for line in first_lines):
                        index_files.append(path)
        return index_files

    def parse_barrel_exports(self, file_path: Path) -> List[Tuple[str, Path]]:
        """Extract exports from a barrelsby-generated index.ts file."""
        exports = []
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Match barrelsby export pattern
        pattern = r'export \* from "(.*?)";'
        matches = re.finditer(pattern, content)

        for match in matches:
            relative_path = match.group(1)
            full_path = (file_path.parent / Path(relative_path)).resolve().with_suffix('.ts')
            if full_path.exists():
                exports.append((relative_path, full_path))

        return exports

    def parse_source_exports(self, file_path: Path) -> Set[str]:
        """Extract named exports from a TypeScript source file."""
        exports = set()
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Match export patterns (interface, type, class, etc.)
        pattern = r'export\s+(?:interface|type|class|const|let|var|function|enum)\s+([^\s<({]+)'
        matches = re.finditer(pattern, content)

        for match in matches:
            exports.add(match.group(1))

        return exports

    def parse_named_exports(self, file_path: Path) -> List[Tuple[str, str]]:
        """Extract named exports with their package sources from a TypeScript file.

        Args:
            file_path (Path): Path to the TypeScript file to analyze

        Returns:
            List[Tuple[str, str]]: List of tuples containing (export_name, package_name)
        """
        named_exports = []
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.readlines()

        # Match pattern: export { Name1, Name2 } from '@package/name';
        pattern = r"export\s*{([^}]+)}\s*from\s*'([^']+)'"

        for line in content:
            match = re.search(pattern, line)
            if match:
                # Get the exports and package
                exports_str = match.group(1)
                package_name = match.group(2)

                # Split and clean the export names
                export_names = [name.strip() for name in exports_str.split(',')]

                # Add each export with its package
                for export_name in export_names:
                    # Handle 'as' aliases by taking the original name
                    if ' as ' in export_name:
                        export_name = export_name.split(' as ')[0].strip()
                        export_name = export_name
                    named_exports.append((export_name, package_name))

        return named_exports

    def analyze_project(self) -> Dict[str, str]:
        """Analyze the entire project and create an export map."""
        # First, process barrel files as before
        index_files = self.find_index_files()

        for index_file in index_files:
            project_path = index_file.relative_to(self.root_path).parent.parent
            project_name = str(project_path).replace('\\', '/').split('/')[-1].replace('.', '-')
            package_name = f'@tektonux/{project_name}'

            # Process each exported file in the barrel
            barrel_exports = self.parse_barrel_exports(index_file)
            for _, source_file in barrel_exports:
                exports = self.parse_source_exports(source_file)
                for export_name in exports:
                    self.export_map[export_name] = package_name

        # Now, scan all TypeScript files for named exports
        for ts_file in self.root_path.rglob("*.ts"):
            if "node_modules" not in str(ts_file) and "dist" not in str(ts_file):
                named_exports = self.parse_named_exports(ts_file)
                for export_name, package_name in named_exports:
                    self.export_map.setdefault(export_name, package_name)

        return self.export_map

    def save_export_map(self, output_path: str = None):
        """Save the export map as a JavaScript module with timestamp."""
        from datetime import datetime

        if output_path is None:
            output_path = OUTPUT_PATH

        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        # Format the export map as a string with proper indentation
        export_entries = []
        exported_keys = set()
        for key, value in sorted(self.export_map.items()):
            key_fixed = key.replace(":", "")
            if key_fixed not in exported_keys:
                export_entries.append(f"        '{key_fixed}': '{value}'")
                exported_keys.add(key_fixed)

        formatted_exports = ',\n'.join(export_entries)

        js_content = f"""// Contents from `python ./tools/shared/testing/gather_all_imports.py`
// Generated on {timestamp}

export const allImports =
    {{
{formatted_exports}
    }}
;
"""

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(js_content)


def main():
    analyzer = TypeScriptImportAnalyzer()
    export_map = analyzer.analyze_project()
    analyzer.save_export_map()
    print(f"Found {len(export_map)} exports across all projects")


if __name__ == "__main__":
    main()
