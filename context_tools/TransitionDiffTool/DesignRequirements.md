# Code Context Manager - Technical Requirements Specification
# Date: March 6, 2025

## 1. Overview and Purpose
The Code Context Manager is a Blazor-based utility tool designed to:
1. Collect context from multiple code files for sharing with LLMs
2. Apply code changes generated by LLMs back to the original files
3. Provide a streamlined workflow for LLM-assisted development

## 2. Architecture
- Client and server Blazor architecture
- Slim two-column UI design optimized for edge-docking
- Tab-based navigation in left column
- Status reporting in right column

## 3. UI Requirements

### 3.1. Overall Layout
- Two-column layout with resizable panels
- Minimal width optimized for docking to screen edge
- Persistent UI state between sessions
- Left column with tab navigation between collection and edit modes
- Right column for status and operation feedback

### 3.2. Directory/File Selection Tab
- Path selection input with browse button
- Hierarchical tree view of files and directories
- Selection checkboxes for files and directories
- "Collect Context" button prominently displayed
- Optional quick filters for file extensions

### 3.3. Edit Application Tab
- Multi-line text input area for pasting LLM responses containing XDiff
- "Apply Edits" button
- Optional format validation indicator
- Clear button to reset edit content

### 3.4. Status Column
- Operation status indicators (idle, processing, complete)
- Scrollable log area with timestamps
- Color-coded messages (error, warning, info)
- Clear logs button
- Copy logs to clipboard functionality

## 4. Functional Requirements

### 4.1. Context Collection
- Browse dialog for selecting root directory
- Memory of recent paths (last 5-10)
- Expand/collapse nodes in file tree
- Multi-select capability for files/directories
- Scan and read text-based files only
- Insert clear file headers/separators between content
- Handle files with various encodings
- Clipboard integration with success notification
- File size cutoff warnings for large files

### 4.2. Edit Application
- Parse standard XDiff format from pasted text
- Extract target file paths and proposed changes
- Format validation (if not overly complex to implement)
- File path resolution:
  - Support for absolute paths
  - Support for project-root-relative paths
  - Filename-only search throughout directory hierarchy
- Confirmation modal:
  - List all files to be changed before processing
  - Accept/reject buttons for each file
  - Bulk accept/reject options
- Progress indication for multi-file edits

### 4.3. Path Resolution for Ambiguous Matches
- Modal dialog for resolving ambiguous matches (same filename in multiple locations)
- Clear display of possible file paths
- Selection mechanism for choosing correct file
- "Remember this choice" option for repeated edits

### 4.4. Backup Functionality
- Option to backup changed files to timestamped folder (e.g., ./bak202503061046)
- Configurable backup option (enabled/disabled)
- Verification of backup success before applying changes

## 5. Technical Considerations

### 5.1. File System Operations
- Handle permission denied scenarios gracefully
- Provide clear feedback when files can't be accessed
- Consider elevation options for restricted locations
- Implement lazy loading for directory tree
- Use virtualization for large file lists

### 5.2. Content Processing
- Detect and handle file encodings
- Memory-efficient processing
- Skip binary files with configurable extension list
- Detect if file was modified since context collection

### 5.3. XDiff Processing
- Define clear XDiff format expectations
- Robust parsing to handle minor format variations
- Clear error messages for malformed diffs
- Line number preservation for accurate diff application

### 5.4. Error Handling
- Implement global exception handler
- Log detailed errors with user-friendly messages
- Provide recovery options where possible
- Include operation IDs in logs for traceability

## 6. Non-Functional Requirements

### 6.1. Performance
- Responsive UI even during file operations
- Background processing for lengthy operations
- Cancel mechanism for long-running tasks
- Memory management for large file collections

### 6.2. Security
- No transmission of file contents outside local system
- Respect file system permissions
- Verify write permissions before attempting changes

### 6.3. Usability
- Intuitive navigation and selection
- Clear status feedback
- Keyboard shortcuts for common operations
- Error messages that suggest resolution steps

## 7. Implementation Notes

### 7.1. Development Approach
- Start with core file system and clipboard functionality
- Implement context collection first (simpler flow)
- Build robust XDiff parser as separate testable component
- Add file path resolution with ambiguity handling
- Create confirmation modal with per-file accept/reject

### 7.2. Project Structure
- Separate concerns with clear service interfaces
- Unit test critical components (XDiff parser, path resolution)
- Use MVVM pattern for separation of UI and logic
- Modular components for reusability

### 7.3. Key Services
- FileSystemService: Directory browsing, file I/O operations
- ContextCollectorService: Manage selections, generate context
- EditProcessorService: Parse and apply XDiff changes
- BackupService: Create timestamped backups of files
- StatusReporterService: Log and display operation status
